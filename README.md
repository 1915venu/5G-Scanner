# 5G NR Cell Detection - Complete Theory Guide ðŸ“–
## Verified Against 3GPP TS 38.211 V17.4.0

---

# PART 1: OFDM FUNDAMENTALS

## 1.1 What is OFDM?

**OFDM = Orthogonal Frequency Division Multiplexing**

### The Core Idea

Instead of transmitting one high-speed data stream on a single wide carrier, OFDM transmits many low-speed streams on many narrow carriers **simultaneously**.

```
Single Carrier (Traditional):
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 20 MHz â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   One stream at 100 Mbps
   
OFDM (Multi-Carrier):
   â”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚â–ˆâ”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 20 MHz â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   2048 streams at ~50 kbps each = 100 Mbps total
```

### Why "Orthogonal"?

Subcarriers are spaced exactly so their peaks align with zeros of neighbors:

```
Subcarrier 1:  â•±â•²     â•±â•²     â•±â•²
Subcarrier 2:     â•±â•²     â•±â•²     â•±â•²
                â†‘
            Zero crossing of SC1 = peak of SC2
```

**Mathematically:** Subcarriers at frequencies fâ‚€, fâ‚€+Î”f, fâ‚€+2Î”f, ... are orthogonal over period T if:
```
âˆ«â‚€áµ€ e^(j2Ï€fâ‚t) Ã— e^(-j2Ï€fâ‚‚t) dt = 0  when fâ‚ â‰  fâ‚‚
```

This requires **Î”f = 1/T** (subcarrier spacing = 1/symbol duration)

### 5G NR Subcarrier Spacings

| Numerology (Î¼) | Subcarrier Spacing | Symbol Duration | Use Case |
|---------------|-------------------|-----------------|----------|
| 0 | 15 kHz | 66.67 Î¼s | FR1 (sub-6 GHz) |
| 1 | 30 kHz | 33.33 Î¼s | FR1 (common) |
| 2 | 60 kHz | 16.67 Î¼s | FR1/FR2 |
| 3 | 120 kHz | 8.33 Î¼s | FR2 (mmWave) |
| 4 | 240 kHz | 4.17 Î¼s | FR2 (SSB only) |

**Formula:** Symbol duration T = 1/SCS

---

## 1.2 FFT and OFDM

### The Mathematical Foundation

**Transmitter (IFFT):**
```
x(n) = (1/âˆšN) Ã— Î£â‚–â‚Œâ‚€á´ºâ»Â¹ X(k) Ã— e^(j2Ï€kn/N)

Where:
- X(k) = data symbol on subcarrier k (frequency domain)
- x(n) = time domain sample n
- N = FFT size
```

**Receiver (FFT):**
```
X(k) = (1/âˆšN) Ã— Î£â‚™â‚Œâ‚€á´ºâ»Â¹ x(n) Ã— e^(-j2Ï€kn/N)
```

### Why FFT is Efficient

Direct computation: O(NÂ²) operations
FFT algorithm: O(N log N) operations

For N=2048: FFT is ~200Ã— faster!

### Sample Rate Formula

```
Sample Rate = FFT Size Ã— Subcarrier Spacing

Example (5G NR Î¼=0):
30.72 MHz = 2048 Ã— 15 kHz
```

---

## 1.3 Cyclic Prefix (CP)

### The Multipath Problem

Wireless signals reflect off buildings, arriving at different times:

```
Time â†’
                    
TX:  [Symbol 1        ][Symbol 2        ]
                â†“ direct path (fast)
RX:  [Symbol 1        ][Symbol 2        ]
                â†“ reflected path (delayed by Ï„)
RX:     [Symbol 1     ][Symbol 2     ]...
              â†‘
         Symbols OVERLAP = Inter-Symbol Interference (ISI)
```

### The CP Solution

**Copy the last Ncp samples of the symbol to the beginning:**

```
Original:    [         sâ‚€ sâ‚ sâ‚‚ ... sâ‚™â‚‹â‚ƒ sâ‚™â‚‹â‚‚ sâ‚™â‚‹â‚]
                                       â†“ â†“ â†“ (copy)
With CP:     [sâ‚™â‚‹â‚ƒ sâ‚™â‚‹â‚‚ sâ‚™â‚‹â‚ | sâ‚€ sâ‚ sâ‚‚ ... sâ‚™â‚‹â‚ƒ sâ‚™â‚‹â‚‚ sâ‚™â‚‹â‚]
              â””â”€â”€â”€â”€CPâ”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Main Symbolâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How CP Prevents ISI

```
TX: [CP][Main Symbol][CP][Main Symbol]...

Delayed reflections land in CP region:
    [CP][Main Symbol][CP][Main Symbol]
     â†‘
   ISI absorbed here (receiver discards CP)
```

**Key Requirement:** CP length > maximum delay spread

### 5G NR CP Lengths

| Numerology | Normal CP (samples) | Extended CP |
|------------|---------------------|-------------|
| Î¼=0 (15 kHz) | 144/160 | 512 |
| Î¼=1 (30 kHz) | 72/80 | - |

First symbol of each slot has slightly longer CP (160 vs 144).

---

## 1.4 OFDM Symbol Structure

### Complete Symbol

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CP    â”‚        Useful Symbol         â”‚
â”‚(144 samp)â”‚       (2048 samples)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚â† FFT window (exactly here!) â†’â”‚
           
Total samples = 2048 + 144 = 2192 (first symbol: 2048+160=2208)
```

### Timing Relationships

For Î¼=0 (15 kHz SCS), sample rate = 30.72 MHz:
```
Symbol duration = 2048/30.72e6 = 66.67 Î¼s
CP duration = 144/30.72e6 = 4.69 Î¼s
Total OFDM symbol = 2192/30.72e6 = 71.35 Î¼s
```

---

# PART 2: SEQUENCES AND SIGNAL GENERATION

## 2.1 M-Sequences (Maximum Length Sequences)

### Definition

An m-sequence is generated by a **Linear Feedback Shift Register (LFSR)** with specific tap positions.

### LFSR Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”
â”‚  â”‚xâ‚€ â”‚â”€â”€â–¶â”‚xâ‚ â”‚â”€â”€â–¶â”‚xâ‚‚ â”‚â”€â”€â–¶â”‚xâ‚ƒ â”‚â”€â”€â–¶â”‚xâ‚„ â”‚â”€â”€â–¶â”‚xâ‚… â”‚â”€â”€â–¶â”‚xâ‚† â”‚â”€â”€â–¶ output
â”‚  â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜
â”‚    â”‚                       â”‚                       â–²
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€XORâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                (feedback)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Polynomial: xâ· + xâ´ + 1
Feedback: xâ‚‡ = xâ‚„ âŠ• xâ‚€  (XOR)
```

### Mathematical Formulation

For polynomial xâ· + xâ´ + 1:
```
x(n+7) = [x(n+4) + x(n)] mod 2
```

This is exactly what the code does:
```python
for i in range(120):
    next_val = (x[i+4] + x[i]) % 2  # Same as XOR
    x = np.append(x, next_val)
```

### Key Properties

| Property | Value | Explanation |
|----------|-------|-------------|
| Length | 2â¿ - 1 | For n=7 bits â†’ 127 |
| Balance | (2â¿â»Â¹) ones, (2â¿â»Â¹-1) zeros | 64 ones, 63 zeros |
| Runs | Specific pattern | Predictable run lengths |
| **Autocorrelation** | **Special!** | See below |

### Autocorrelation Property (CRITICAL!)

For m-sequence {aâ‚™} with BPSK mapping (0â†’+1, 1â†’-1):

```
         â”Œ N,    if Ï„ = 0 (mod N)
R(Ï„) =   â”‚
         â”” -1,   if Ï„ â‰  0 (mod N)
         
Where N = 2â¿ - 1 = 127 for PSS
```

**Visual:**
```
                    Peak = 127
                       â”‚
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    -1  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  baseline
                       â†‘
                    Ï„ = 0
```

**Why This Matters:** When correlating received signal with known m-sequence:
- Perfect alignment â†’ huge peak (127)
- Any misalignment â†’ near zero (-1)
- **21 dB peak-to-sidelobe ratio** = robust detection!

---

## 2.2 PSS - Primary Synchronization Signal

### Reference: 3GPP TS 38.211 Section 7.4.2.2

### PSS Sequence Definition

The PSS is derived from m-sequence using:

```
d_PSS(n) = 1 - 2Â·x(m)

where:
  m = (n + 43Â·N_ID_2) mod 127
  n = 0, 1, 2, ..., 126
  N_ID_2 âˆˆ {0, 1, 2}
```

### M-Sequence for PSS

**Initial condition:** x(6)=1, x(5)=1, x(4)=1, x(3)=0, x(2)=1, x(1)=1, x(0)=0

Or written as array: `[0, 1, 1, 0, 1, 1, 1]` (xâ‚€ to xâ‚†)

**Recurrence:** x(i+7) = [x(i+4) + x(i)] mod 2

### Why 43?

The sequences for N_ID_2 = 0, 1, 2 are **cyclic shifts** of each other:
- N_ID_2=0: shift by 0
- N_ID_2=1: shift by 43
- N_ID_2=2: shift by 86

**43 = 127/3 rounded** ensures maximum distance between sequences for better detection.

### BPSK Mapping

```
x(m) = 0  â†’  d_PSS(n) = 1 - 2Ã—0 = +1
x(m) = 1  â†’  d_PSS(n) = 1 - 2Ã—1 = -1
```

### PSS in Resource Grid

PSS occupies **127 subcarriers** centered in the SS/PBCH block:

```
Subcarrier index (k) relative to SSB:
  k = 56, 57, 58, ..., 182 (127 subcarriers)
  = n - 63 + 56 to n + 63 + 56
  
In FFT bins (DC-centered):
  bins -63 to +63 around center
```

---

## 2.3 SSS - Secondary Synchronization Signal

### Reference: 3GPP TS 38.211 Section 7.4.2.3

### SSS Sequence Definition

```
d_SSS(n) = [1 - 2Â·xâ‚€((n + mâ‚€) mod 127)] Ã— [1 - 2Â·xâ‚((n + mâ‚) mod 127)]

where:
  mâ‚€ = 15Â·âŒŠN_ID_1/112âŒ‹ + 5Â·N_ID_2
  mâ‚ = N_ID_1 mod 112
  n = 0, 1, 2, ..., 126
```

### Two Different M-Sequences

**Sequence xâ‚€:** (same as PSS)
- Initial: xâ‚€(6)=0, xâ‚€(5)=0, xâ‚€(4)=0, xâ‚€(3)=0, xâ‚€(2)=0, xâ‚€(1)=0, xâ‚€(0)=1
- Or: `[1, 0, 0, 0, 0, 0, 0]`
- Recurrence: xâ‚€(i+7) = [xâ‚€(i+4) + xâ‚€(i)] mod 2

**Sequence xâ‚:** (DIFFERENT polynomial!)
- Initial: xâ‚(6)=0, xâ‚(5)=0, xâ‚(4)=0, xâ‚(3)=0, xâ‚(2)=0, xâ‚(1)=0, xâ‚(0)=1
- Or: `[1, 0, 0, 0, 0, 0, 0]`
- Recurrence: xâ‚(i+7) = [xâ‚(i+1) + xâ‚(i)] mod 2 **(note: i+1, not i+4!)**

### Index Encoding

| Parameter | Range | Encoding |
|-----------|-------|----------|
| mâ‚€ | 0-167 | mâ‚€ = 15Â·âŒŠN_ID_1/112âŒ‹ + 5Â·N_ID_2 |
| mâ‚ | 0-111 | mâ‚ = N_ID_1 mod 112 |

**Example:** N_ID_1 = 71, N_ID_2 = 2
```
mâ‚€ = 15Â·âŒŠ71/112âŒ‹ + 5Â·2 = 15Â·0 + 10 = 10
mâ‚ = 71 mod 112 = 71
```

### Physical Cell ID (PCI)

```
N_ID_cell = 3 Ã— N_ID_1 + N_ID_2

Range: 0 to 1007 (1008 total)
- N_ID_1: 0 to 335 (336 values from SSS)
- N_ID_2: 0 to 2 (3 values from PSS)
```

---

## 2.4 SSB Structure and Timing

### Synchronization Signal Block (SSB)

SSB contains 4 OFDM symbols:

```
Symbol 0:  PSS (Primary Synchronization Signal)
Symbol 1:  PBCH (Broadcast Channel)
Symbol 2:  PBCH + SSS (Secondary Sync Signal in middle)
Symbol 3:  PBCH
```

```
Subcarriers
    â†‘
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
240 â”‚  â”‚                    PBCH                        â”‚ Symbol 3
    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  â”‚     PBCH      â”‚     SSS      â”‚     PBCH       â”‚ Symbol 2
    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  â”‚                    PBCH                        â”‚ Symbol 1
    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  0 â”‚  â”‚                    PSS                         â”‚ Symbol 0
    â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
                           Time (symbols)
```

### SSS Position Relative to PSS

**SSS is in Symbol 2, PSS is in Symbol 0**

```
Time offset = 2 Ã— (FFT_size + CP_length) samples

For detection code with FFT=256, CP=20:
  offset = 2 Ã— (256 + 20) = 552 samples
```

---

# PART 3: DETECTION AND ESTIMATION

## 3.1 Cross-Correlation Theory

### Definition

Cross-correlation of signals x(n) and y(n):

```
R_xy(Ï„) = Î£â‚™ x(n) Ã— y*(n - Ï„)

Where:
- Ï„ = lag (time offset)
- y* = complex conjugate of y
```

### Correlation as "Sliding Match"

```
Received:   [????â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ????]
Reference:  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]
              â†“ slide â†“
              
Ï„=0:   [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]        R(0) = low
Ï„=10:       [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]   R(10) = medium  
Ï„=20:            [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]  R(20) = HIGH! (matched)
```

### Why M-Sequence Correlation Works

Using autocorrelation property of m-sequences:

```
R(Ï„) = Î£â‚™ d_PSS(n) Ã— d_PSS(n - Ï„)

     = 127  when Ï„ = 0 (perfect alignment)
     = -1   when Ï„ â‰  0 (any misalignment)
```

### Peak-to-Sidelobe Ratio

```
PSR = 20 Ã— log10(127/1) = 42 dB (for perfect signal)

In practice with noise:
  PSR â‰ˆ 20-25 dB typically
```

### FFT-Based Fast Correlation

Direct correlation: O(NÂ²)
FFT-based: O(N log N)

**Method:**
```
R_xy = IFFT(FFT(x) Ã— conj(FFT(y)))
```

Python implementation:
```python
correlation = np.abs(signal.correlate(rx_signal, pss_ref, mode='valid'))
# Uses FFT internally for speed
```

---

## 3.2 PSS Detection Algorithm

### Step-by-Step Process

```
FOR each N_ID_2 in {0, 1, 2}:
    1. Generate reference PSS in time domain
    2. Cross-correlate with received signal
    3. Find correlation peak index
    4. Calculate SNR
    5. Store if SNR > threshold

Sort detections by SNR
Return best detection(s)
```

### SNR Calculation

```
Peak Power = |correlation[peak_index]|Â²
Noise Power = mean(|correlation[other_indices]|Â²)

SNR_dB = 10 Ã— log10(Peak Power / Noise Power)
```

Or using amplitude (as in code):
```python
snr_db = 20 * np.log10(peak_value / noise_avg)
```

### Detection Threshold

Typical threshold: **10-15 dB**

- Too low â†’ false positives (noise peaks detected)
- Too high â†’ miss weak cells

---

## 3.3 SSS Detection Algorithm

### After PSS Detection

Once PSS is found, we know:
- Timing (sample index)
- N_ID_2 (0, 1, or 2)

### SSS Search

```
1. Calculate SSS symbol position from PSS timing
2. Extract SSS symbol from received signal
3. FFT to get frequency domain
4. Extract central 127 subcarriers
5. FOR each N_ID_1 in {0, 1, ..., 335}:
     - Generate reference SSS(N_ID_1, N_ID_2)
     - Compute correlation
6. Select N_ID_1 with maximum correlation
```

### Frequency Domain Correlation

For SSS, we correlate in frequency domain:
```python
corr = np.abs(np.sum(sss_rx_127 * np.conj(sss_ref)))
```

This is efficient because SSS is defined in frequency domain.

---

## 3.4 CFO Estimation

### What is CFO?

**Carrier Frequency Offset** = difference between TX and RX oscillator frequencies.

```
Received signal: r(t) = s(t) Ã— e^(j2Ï€Î”ft)

Where Î”f = CFO (can be hundreds to thousands of Hz)
```

### Effect on OFDM

After FFT at receiver with CFO present:

```
Y(k) = X(k) Ã— sin(Ï€ÎµN)/sin(Ï€Îµ/N) Ã— e^(jÏ€Îµ(N-1)/N) + ICI

Where Îµ = Î”f / SCS = normalized CFO
```

**Problems:**
1. Phase rotation (affects all subcarriers)
2. Inter-Carrier Interference (ICI)

### CP-Based Estimation Method

**Key idea:** CP is identical to symbol tail

```
Without CFO:
  CP samples = tail samples (identical)
  
With CFO:
  CP samples = tail samples Ã— e^(j2Ï€Î”fÂ·N/Fs)
```

### Mathematical Derivation

Let r(n) be received signal with CFO:
```
r(n) = s(n) Ã— e^(j2Ï€Î”fÂ·n/Fs)
```

CP correlation:
```
R = Î£áµ¢ r(i) Ã— r*(i + N)

  = Î£áµ¢ s(i)Ã—e^(j2Ï€Î”fÂ·i/Fs) Ã— s*(i+N)Ã—e^(-j2Ï€Î”fÂ·(i+N)/Fs)
  
  = Î£áµ¢ |s(i)|Â² Ã— e^(-j2Ï€Î”fÂ·N/Fs)  [since s(i) = s(i+N) in CP region]
  
  = P Ã— e^(-jÏ†)
```

Where:
- P = power of CP samples
- Ï† = 2Ï€Î”fÂ·N/Fs = phase rotation

### CFO Extraction

```
Ï† = angle(R) = 2Ï€Î”fÂ·N/Fs

Therefore:
Î”f = Ï†Â·Fs / (2Ï€Â·N)

Normalized CFO:
Îµ = Î”f/SCS = Ï†/(2Ï€)
```

**Code implementation:**
```python
corr = np.sum(cp_late * np.conj(cp_early))
cfo = np.angle(corr) / (2 * np.pi)  # normalized CFO
```

### CFO Range

CP-based method can only estimate CFO up to Â±0.5 Ã— SCS:
```
|Îµ| â‰¤ 0.5  â†’  |Î”f| â‰¤ SCS/2 = 7.5 kHz (for 15 kHz SCS)
```

For larger CFO, additional coarse estimation needed.

---

## 3.5 RSRP - Reference Signal Received Power

### Definition (3GPP TS 38.215)

RSRP is the **linear average** of power contributions of resource elements carrying reference signals.

### Simplified Calculation

```
RSRP = (1/N) Ã— Î£ |reference_signal_sample|Â²

In dBm:
RSRP_dBm = 10 Ã— log10(RSRP) + 30
```

### Quality Mapping

| RSRP (dBm) | Quality | Typical Scenario |
|------------|---------|------------------|
| â‰¥ -80 | Excellent | Near tower |
| -80 to -90 | Good | Outdoor urban |
| -90 to -100 | Fair | Indoor |
| -100 to -110 | Poor | Cell edge |
| < -110 | Very Poor | Handover needed |

---

# PART 4: PUTTING IT ALL TOGETHER

## 4.1 Complete Detection Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SIGNAL CAPTURE                       â”‚
â”‚   Antenna â†’ LNA â†’ Mixer â†’ ADC â†’ I/Q Samples            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PSS DETECTION                         â”‚
â”‚   For N_ID_2 = 0, 1, 2:                                â”‚
â”‚     â€¢ Generate PSS reference                            â”‚
â”‚     â€¢ Cross-correlate with signal                       â”‚
â”‚     â€¢ Find peak, calculate SNR                          â”‚
â”‚   â†’ Outputs: timing, N_ID_2, SNR                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CFO ESTIMATION                         â”‚
â”‚   â€¢ Extract CP region at detected timing                â”‚
â”‚   â€¢ Correlate CP with symbol tail                       â”‚
â”‚   â€¢ Extract phase â†’ frequency offset                    â”‚
â”‚   â†’ Outputs: normalized CFO                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   SSS DETECTION                         â”‚
â”‚   â€¢ Go to SSS position (2 symbols after PSS)           â”‚
â”‚   â€¢ FFT to frequency domain                            â”‚
â”‚   â€¢ For N_ID_1 = 0 to 335:                             â”‚
â”‚       â€¢ Generate SSS(N_ID_1, N_ID_2)                   â”‚
â”‚       â€¢ Correlate                                       â”‚
â”‚   â†’ Outputs: N_ID_1                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CALCULATE PCI                         â”‚
â”‚   PCI = 3 Ã— N_ID_1 + N_ID_2                            â”‚
â”‚                                                         â”‚
â”‚   Example: N_ID_1=71, N_ID_2=2                         â”‚
â”‚            PCI = 3Ã—71 + 2 = 215                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4.2 Formula Reference Card

### Core Identities
```
PCI = 3 Ã— N_ID_1 + N_ID_2
N_ID_1 = 0...335, N_ID_2 = 0...2
Total PCIs = 1008
```

### OFDM Parameters
```
Sample Rate = FFT_size Ã— SCS
Symbol Duration = 1/SCS = FFT_size/Sample_Rate
CP Duration = CP_len/Sample_Rate
```

### M-Sequence PSS
```
d_PSS(n) = 1 - 2Ã—x((n + 43Ã—N_ID_2) mod 127)
x(i+7) = [x(i+4) + x(i)] mod 2
Initial: x = [0,1,1,0,1,1,1]
```

### M-Sequences SSS
```
d_SSS(n) = dâ‚€(n) Ã— dâ‚(n)
dâ‚€(n) = 1 - 2Ã—xâ‚€((n + mâ‚€) mod 127)
dâ‚(n) = 1 - 2Ã—xâ‚((n + mâ‚) mod 127)

mâ‚€ = 15Ã—âŒŠN_ID_1/112âŒ‹ + 5Ã—N_ID_2
mâ‚ = N_ID_1 mod 112

xâ‚€: xâ‚€(i+7) = [xâ‚€(i+4) + xâ‚€(i)] mod 2
xâ‚: xâ‚(i+7) = [xâ‚(i+1) + xâ‚(i)] mod 2
Both initial: [1,0,0,0,0,0,0]
```

### CFO
```
Normalized CFO: Îµ = angle(Î£ cp_late Ã— cp_early*) / (2Ï€)
CFO in Hz: Î”f = Îµ Ã— SCS
```

### SNR
```
SNR_dB = 20 Ã— log10(peak_amplitude / noise_amplitude)
       = 10 Ã— log10(peak_power / noise_power)
```

---

**This document is verified against 3GPP TS 38.211 V17.4.0** âœ…
